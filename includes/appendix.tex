\section{Appendix}

In this section, we will prove some of the guarantees that transformations
provide in \fuzzer{}.

We assume that the reader is familiar with SMT-LIB syntax. The transformations
work over boolean, integer, string literals and expressions, and regular
expressions.

We will make the folowing simplifications for our proofs:
\begin{itemize}
  \item
    Since many of the operators can be expressed in terms of other, our
    proofs will only consider a subset of the operators. In particular we will
    drop the following:
    \begin{itemize}
      \item \texttt{|} (boolean or)
      \item \texttt{=} for boolean expressions
      \item \texttt{<=}, \texttt{>}, \texttt{>=}
      \item \texttt{str.prefixof}, \texttt{str.suffixof}, \texttt{str.at}
      \item \texttt{str.contains}
      \item \texttt{re.range}
    \end{itemize}

  \item
    In the above, we assume that \texttt{str.at} is expressible using
    \texttt{substring} although the semantics slightly different when the index
    is out of bounds.

  \item
    We will assume that our program instances are a single assertion. Multiple
    assertions can be expressed by combining them using \texttt{and}.
\end{itemize}

\begin{definition}
  A \emph{model} is a mapping from boolean, integer, and string variables to
literals of the corresponding type.
\end{definition}

\begin{definition}
  A \emph{program} $P$ satisfies a model $m$ if $P$ evaluates to \texttt{true}
under the model $m$. The function $\eval (P)$ evaluates a program instance
under a model; the specific model used is left implicit.
\end{definition}

The proofs all follow a very similar structure. For each transformation
\textit{Trans}, we show that a problem instance $P$ is satisfiable by a model $m$
if and only if $\textit{Trans}(P)$ is satisfiable by $\textit{Trans}(m)$, where
$\textit{Trans}(M)$ is the transformation applied to all the constants in the
model $m$.

To show the above, we show that for all expressions $e$, $\textit{Trans}(\eval
(e)) = \eval (\textit{Trans}(e))$. This is proven using a straightforward
induction on the structure of expressions. Since the transformations fix
boolean constants, we have, $\textit{Trans}(\eval (P)) = \eval (P)$, and hence
if the original problem is satisfiable then the transformed problem is also
satisfiable.

For transformations that have an inverse, such as \textit{Translate}
and \textit{Reverse} this also shows that if the transformed problem is
satisfiable, then the original problem is satisfiable. This proves that these
transformations are equisat transformations. \textit{Multiply} does not have an
inverse and hence it only guarantees to take satisfiable problems to satisfiable
problems. This can be seen in the problem instance $y<x<y+1$ which is UNSAT, but
multiplying by 2 transforms the problem into $y<x<y+2$ which is SAT.

\subsection{Translate}
We now prove that translate transforms programs into equisatisfiable programs.
