\section{Experiments}

    Here we present two particular sets of problems generated by \fuzzer{}: \cHard{} and \zHard{}. These two problem sets were unique in their ability to elicit poor performance in one solver, but not another. Full details of test scripts, configurations, and problems that were used in the experiment can be found in the Appendix.

    % TODO:
    % - supply machine environment description
    % - supply install scripts that produce trace builds
    % - supply test scripts that invoke the solvers and produce traces

    \subsection{Data}

        \subsubsection{Performance on \cHard{}}

            On this problem set \cvc{} did poorly, but \us{} did well. The graphs in Figures~\ref{fig:z3str3-cvc4-hard} and ~\ref{fig:cvc4-cvc4-hard} show the performance results for both solvers. We produce and analyse the execution trace files both solvers' execution on the problem set.

            \begin{figure}[h]
                \begin{subfigure}{.5\textwidth}
                    \includegraphics[width=\textwidth]{data/graphs/cvc4-cvc4-hard.png}
                    \caption{Performance of \cvc{} on \cHard{}}
                    \label{fig:cvc4-cvc4-hard}
                \end{subfigure}
                \begin{subfigure}{.5\textwidth}
                    \includegraphics[width=\textwidth]{data/graphs/z3str3-cvc4-hard.png}
                    \caption{Performance of \us{} on \cHard{}}
                    \label{fig:z3str3-cvc4-hard}
                \end{subfigure}
                \caption{Results on \cHard}
                \label{fig:cvc4-hard}
            \end{figure}

            The \cvc{} trace file indicates that it performs the following operations:

            \begin{enumerate}
                \item Loads all facts into its database.
                \item Flattens binary concatenations into n-ary concatenations.
                \item Computes equivalence classes for strings and integers.
            \end{enumerate}

            At this stage it discovers that there is a conflict in one of its equivalence classes, as shown in Figure~\ref{fig:cvc4-conflict}. After discovering the conflict, the rest of the trace is filled with apparently the same operation repeated hundreds of thousands of times. After this operation is finished, \cvc{} recalls the earlier conflict and returns \texttt{unsat}.

            \begin{figure}[h]
                {\scriptsize\begin{verbatim}
CONFLICT: Eq engine conflict : (and
(= "woof" (str.++ "woof" lsym_5 ... lsym_5))
(= "" lsym_5)
(= "" var3) ... (= "" var30)
(= (str.++ "woof" var3 ... var30) (str.++ "meow" var43 ... var70))
(= "" var43) ... (= "" var70)
(= "meow" (str.++ "meow" lsym_5 ... lsym_5)))\end{verbatim}}
                \caption{Evidence of \cvc{} detecting conflict}
                \label{fig:cvc4-conflict}
            \end{figure}

            \us{} showed different behaviour on this problem set. It follows a similar process as \cvc{}, except it does not flatten concatenations. In contrast to \cvc{}, \us{} immediately returns \texttt{unsat} as soon as it verifies consistency of equivalence classes as it constructs them, as shown in Figure~\ref{fig:z3str3-conflict}.

            \begin{figure}[h]
                {\scriptsize\begin{verbatim}
-------- [str] new_eq_check ../src/smt/theory_str.cpp:1864 ---------
checking whether (str.++ "woof" var2) and (str.++ "meow" var42) can be equal
------------------------------------------------
-------- [str] new_eq_check ../src/smt/theory_str.cpp:1867 ---------
inconsistency detected: (str.++ "woof" var2) cannot be equal to (str.++ "meow" var42)
------------------------------------------------
-------- [str] assert_axiom ../src/smt/theory_str.cpp:179 ---------
asserting (not (= (str.++ "woof" var2) (str.++ "meow" var42)))
------------------------------------------------\end{verbatim}}
                \caption{Evidence of \us{} detecting conflict}
                \label{fig:z3str3-conflict}
            \end{figure}

            % TODO:
            % - \us{} cactus plot
            % - \cvc{} cactus plot
            % - comparison plot

        \subsubsection{Performance on \zHard{}}

            On this problem set \cvc{} did well, but \us{} did poorly. The graphs in Figures~\ref{fig:z3str3-z3str3-hard} and ~\ref{fig:cvc4-z3str3-hard} show the performance results for both solvers. We produce and analyse the execution trace files both solvers' execution on the problem set, and present them in the Appendix.

            \begin{figure}[h]
                \begin{subfigure}{.5\textwidth}
                    \includegraphics[width=\textwidth]{data/graphs/cvc4-z3str3-hard.png}
                    \caption{Performance of \cvc{} on \zHard{}}
                    \label{fig:cvc4-z3str3-hard}
                \end{subfigure}
                \begin{subfigure}{.5\textwidth}
                    \includegraphics[width=\textwidth]{data/graphs/z3str3-z3str3-hard.png}
                    \caption{Performance of \us{} on \zHard{}}
                    \label{fig:z3str3-z3str3-hard}
                \end{subfigure}
                \caption{Results on \zHard}
                \label{fig:z3str3-hard}
            \end{figure}

            Both solvers exhibit similar patterns in their trace files. They differ in their strategies for assigning possible satisfying assignments. \cvc{} assigns the first variable to a constant and all other variables to the empty string. \us{} however seems to ``drag'' the constant across the equation, splitting its characters among the variables in it.

            % TODO:
            % - \us{} cactus plot
            % - \cvc{} cactus plot
            % - comparison plot

        \subsubsection{Performance Concats-Extracts}

            \todo{}: No data on this yet.

    \subsection{Analysis}

        This section presents our analysis of the observed behaviour of \cvc{} and \us{} on \cHard{} and \zHard{} problems.

        \todo{}: On \cHard{}, \cvc{} does poorly and \us{} does well because ...

        \todo{}: On \zHard{}, \cvc{} does well and \us{} does poorly because ...
