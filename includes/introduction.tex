\section{Introduction}

    Many SMT solvers supporting the theory of strings (e.g., CVC4 \cite{cvc4},  Z3str2 \cite{z3str2}, Norn \cite{norn} 
    and Z3str3 \cite{z3str3}) have been developed over the past decade. 
    To validate and benchmark their solvers, many developers have relied on hand-crafted suites \cite{cvc4-tests} 
    \cite{z3str3-tests} \cite{z3str2-tests} or industrial examples \cite{kaluza} \cite{kausler}. 
    These test suites have helped developers identify implementation defects and develop more sophistic solving heuristics. 
    However, the suites cover a limited problem space, can be difficult to create, and hard to acquire.
    
    In contrast, fuzzing can systematically generate diverse test cases with little effort. 
    Guided by different rules, fuzzing can also be applied to generate instances designed to challenge selected capacities. 
    Inspired by traditional fuzzers, we introduce a fuzzer for string solvers, \fuzzer{}, 
    and describe its utility as an exploratory validation tool. 
    We demonstrate its effectiveness by presenting defects and limitations it helped identify in leading solvers.
    More specifically, we contribute
    \begin{enumerate}
        \item \textbf{The \fuzzer{} tool}. We describe a modular fuzzer which can transform and generate \smtfull{} string and regex problems. We briefly document its components and architecture. 
        We provide examples to demonstrate its usefulness as an exploratory tool for validating solvers. 
        We additionally detail its regex-generating and transforming capabilities.
        \item \textbf{A repository of \smtfull{} problems}. We present a repository of \smtfull{} string and regex problem suites 
        generated by \fuzzer{}. We demonstrate the usefulness of these suites by revealing specific defects they helped uncover and fix in \us{}.
        \item \textbf{Experimental Results and Analysis}. We compare \theSolvers{} on the \fuzzer{} suites and present the experimental results. 
        We highlight some suites that cause some solvers to perform poorly poorly in comparison to the others,
        and inspect solver execution traces for some. In the case of \us{}, we
        pinpoint algorithmic limitations that cause the identified poor performance.
    \end{enumerate}
