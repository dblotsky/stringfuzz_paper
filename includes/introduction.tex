\section{Introduction}

    Many SMT solvers that support the theory of strings have been developed over the past decade, and several have matured to the point of being performant and useful in practice. \theSolvers{}\cite{cvc4}\cite{z3str3}\cite{z3str2}\cite{norn} are \numSolvers{} such solvers. Moreover a standard input language for problem instances, \smtfull{}\cite{smt}, has been developed and widely adopted. To validate their solvers, many authors have relied on hand-crafted input suites or real-world examples from industrial applications \cite{cvc4-tests} \cite{z3str3-tests} \cite{z3str2-tests}. Indeed several suites of industrial and hand-crafted problems have been compiled \cite{kaluza} \cite{kausler} to both validate solvers and benchmark their performance. However, though these suites help debug solvers, they do not age well. As solvers continue to grow, fixed benchmarks leave more and more functionality untested.

    We introduce a modular fuzzer for string solvers, \fuzzer{}, and describe its utility as an exploratory validation tool. We show its effectiveness by presenting defects and limitations we were able to find in leading solvers.

    \subsection{Contributions}

        \begin{enumerate}
            \item \textbf{The \fuzzer{} tool}: We describe a modular fuzzer which can transform and generate \smtfull{} string and regex problems. We briefly document its components and modular architecture. We provide some motivating usage patterns to demonstrate its usefulness as an exploratory tool for validating solvers. We additionally detail its regex-generating and transforming capabilities.
            \item \textbf{A repository of \smtfull{} problems}: We present a repository of \smtfull{} string and regex problem suites we generated with \fuzzer{}. We demonstrate the usefulness of these suites by revealing specific defects they helped uncover and fix in \us{}.
            \item \textbf{Experimental Results}: We present experimental runs of \theSolvers{} on the \fuzzer{} suites: \theSuites{}. We picked these suites because they uniquely made some solvers perform poorly, but not others.
            \item \textbf{Analysis}: We analyse our experimental results by inspecting the execution traces of the solvers on the given problems. For \us{} we pinpoint algorithmic limitations that cause the poor performance. For other solvers, we draw superficial conclusions based solely on the execution traces, and invite their authors to conduct further analysis.
        \end{enumerate}
