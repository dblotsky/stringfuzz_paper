\section{Introduction}

    Many SMT solvers supporting the theory of strings (e.g., CVC4 \cite{cvc4},  Z3str2 \cite{z3str2}, Norn \cite{norn} and Z3str3 \cite{z3str3}) have been developed over the past decade. To validate and benchmark their solvers, many authors have relied on hand-crafted input suites \cite{cvc4-tests} \cite{z3str3-tests} \cite{z3str2-tests} or real-world examples from industrial applications \cite{kaluza} \cite{kausler}. These test suites have helped developers identify implementation defects and develop more sophistic solving heuristics. Although extremely helpful, these suites can only cover a limited range of the problem space because they are either manually created or translated from carefully developed programs. 
    
    
    Fuzzing, on the other hand, has already been widely used in similar scenarios to systematically generate more diverse test cases. Guided by different rules, it can also be applied to generate different instances that are particularly designed to challenge selected capacities. Inspired by traditional fuzzers, we introduce a modular fuzzer for string solvers, \fuzzer{}, and describe its utility as an exploratory validation tool. We demonstrate its effectiveness by presenting defects and limitations we were able to identify in leading solvers.
%     Moreover, a standard input language for problem instances, \smtfull{}\cite{smt}, has been developed and widely adopted.
    
    

    \subsection{Contributions}

        \begin{enumerate}
            \item \textbf{The \fuzzer{} tool}: We describe a modular fuzzer which can transform and generate \smtfull{} string and regex problems. We briefly document its components and modular architecture. We provide example usages to demonstrate its usefulness as an exploratory tool for validating solvers. We additionally detail its regex-generating and transforming capabilities.
            \item \textbf{A repository of \smtfull{} problems}: We present a repository of \smtfull{} string and regex problem suites we generated using \fuzzer{}. We demonstrate the usefulness of these suites by revealing specific defects they helped uncover and fix in \us{}.
            \item \textbf{Experimental Results}: We compare \theSolvers{} on the \fuzzer{} suites and selectively present the experimental result on \theSuites{}. We highlighted these suites because they uniquely made some solvers perform poorly, but not others.
            \item \textbf{Analysis}: We analyze our experimental results by inspecting the execution traces of the solvers on the given problems. For \us{}, we pinpoint algorithmic limitations that cause the poor performance. For other solvers, we draw superficial conclusions based solely on the execution traces, and invite their authors to conduct further analysis.
        \end{enumerate}
