\section{Introduction}

In recent years many algorithms for solving string constraints have
been developed and implemented in SMT solvers such as Norn~\cite{norn},
CVC4~\cite{cvc4}, and Z3 (e.g., Z3str2~\cite{z3str2} and Z3str3~\cite{z3str3}).
To validate and benchmark these solvers, their developers have relied on
hand-crafted input suites~\cite{cvc4-tests,z3str3-tests,z3str2-tests} or
real-world examples from a limited class of industrial
applications~\cite{kaluza,kausler}. These test suites have helped
developers identify implementation defects and develop more
sophisticated solving heuristics. Unfortunately, as solvers grow,
fixed benchmarks leave more functionality untested.
There is an acute need for a more robust, inexpensive, and automatic way
of generating benchmarks to test
the correctness and performance of SMT solvers.

Fuzzing is often used to test all kinds of software,
including SAT solvers. Inspired by their utility, we introduce a
fuzzer for string solvers, \fuzzer{}, and describe its value as an
exploratory validation tool. We demonstrate its efficacy
by presenting limitations it helped us find in
leading string solvers. To the best of our knowledge, \fuzzer{} is the
first tool aimed at automatic generation of string constraints. \fuzzer{} can
be used to mutate or transform existing benchmarks, as well as
randomly generate structured instances. These instances can be scaled with
respect to a variety of parameters, e.g., length of string constants,
depth of concats and regeular expressions, number of variables,
number of length constraints, and many more.

\subsubsection{Contributions}

\begin{enumerate}
    \item \textbf{The \fuzzer{} tool}:
        In section~\ref{sec:fuzzer}, we describe a modular fuzzer that can
        transform and randomly generate \smtfull{} string and regular
        expression (regex) instances.\footnote{We assume basic
        familiarity with string solvers and their input
        language.} Scaling inputs (e.g., long string constants,
        deep concatenations) are particularly useful in identifying asymptotic
        behaviors in solvers, and \fuzzer{} has many options to generate such
        scaling inputs. We briefly document \fuzzer{}'s
        components and modular architecture. We provide example use cases to
        demonstrate its utility as an exploratory tool for validating
        solvers.

    \item \textbf{A repository of \smtfull{} instances}:
        We present a repository of \smtfull{} string and regex instance suites
        we generated using \fuzzer{} in section~\ref{sec:suites}. The
        repository consists of two categories: \texttt{generated}, with new
        instances generated by \fuzzer{}, and \texttt{transformed}, with
        transformed instances generated from a small suite of industrial
        benchmarks.

    \item \textbf{Experimental Results and Analysis}:
        We compare the performance of \theSolvers{} on the
        the \fuzzer{} suites \theSuites{} in section~\ref{sec:data}. We
        highlight these suites because they make some solvers perform poorly,
        but not others. We analyze our
        experimental results, and pinpoint algorithmic limitations
        in \us{} that cause poor performance. We propose enhancements that
        address these issues, which \fuzzer{} helped us find.
\end{enumerate}
