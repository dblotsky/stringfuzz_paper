\section{\fuzzer{}}
\label{sec:fuzzer}

\subsubsection{Implementation and Architecture}

\fuzzer{} is implemented as a Python package, and comes with several
executables to generate, transform, and analyze \smtfull{} string and regex
instances. It can either be installed from source, or from the Python
PIP package repository.\footnote{The link to the
source code will be added after double-blind review.}
\fuzzer{} is organized to be easily extended:
all generators and transformers are independent Python modules. To demonstrate
its modularity, we note that the implementations of transformers in \fuzzer{}
contain an average of \linesPerX{} lines of code, whereas the whole fuzzer
contains \linesInFuzzer{} lines.

Its components are also implemented as \unix{} ``filters'', to enable easy
integration with other tools (including themselves). For example, the
outputs of generators can be piped into transformers, and transformers
can be chained to produce a stream of tuned inputs to a
solver. \fuzzer{} is composed of the following tools:
\begin{description}
    \item[\generator{}] \hfill \\
        This tool generates \smt{} instances. It supports several generators and
        options that specify its output. Details can be found in
        table~\ref{tbl:generators}.
    \item[\transformer{}] \hfill \\
        This tool transforms \smt{}
        instances. It supports several transformers and options that specify
        its output and input, which are explained in
        table~\ref{tbl:transformers}. Note that transformers
        \textit{Translate} and \textit{Reverse} also preserve
        satisfiability under certain conditions~\cite{ifaz}.
    \item[\texttt{stringstats}] \hfill \\
        This tool takes an \smt{}
        instance as input and outputs its properties: the number of
        variables/literals, the max/median syntactic depth of expressions, the
        max/median literal length, etc.
\end{description}

\begin{table}[t]
    \centering
    \caption{\generator{} generators.}
    \label{tbl:generators}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Name}
            & \textbf{Generated instances have ...}
            \\ \hline
        \textit{Concats}
            & Long concats and optional random extracts.
            \\ \hline
        \textit{Lengths}
            & Many variables (and their concats) with length constraints.
            \\ \hline
        \textit{Overlaps}
            & An expression of the form A.X = X.B.
            \\ \hline
        \textit{Equality}
            & An equality among concats, each with variables or constants.
            \\ \hline
        \textit{Regex}
            & Regexes of varying complexity.
            \\ \hline
        \textit{Random-Text}
            & Random, likely syntactically \textit{in}valid text.
            \\ \hline
        \textit{Random-AST}
            & Random, but semantically \textit{valid} text.
            \\ \hline
    \end{tabular}

    \caption{\transformer{} transformers.}
    \label{tbl:transformers}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Name}
            & \textbf{The transformer ...}
            \\ \hline
        \textit{Fuzz}
            & Randomly replaces literals and operators with similar ones.
            \\ \hline
        \textit{Graft}
            & For each sort, swaps a random non-leaf node with a leaf node.
            \\ \hline
        \textit{Multiply}
            & Multiplies each number by N, and repeats each character N times.
            \\ \hline
        \textit{Nop}
            & Doesn't transform (but can translate \smtfull{}).
            \\ \hline
        \textit{Reverse}
            & Reverses all string literals and concat arguments.
            \\ \hline
        \textit{Rotate}
            & Performs a random syntax tree rotation on two concats.
            \\ \hline
        \textit{Translate}
            & Maps every character X to a different character Y.
            \\ \hline
        \textit{Unprintable}
            & Randomly replaces all characters in literals with unprintable ones.
            \\ \hline
    \end{tabular}
\end{table}

\subsubsection{Regex Fuzzing Capabilities}

\fuzzer{} can generate
and transform instances with regular expression constraints. The
command \texttt{stringfuzzg regex} invokes the regex instance
generator. It generates a instance of the form:
\begin{align*}
    & \texttt{(assert (str.in.re X}\; R_0\; \texttt{))} \\
    & \texttt{(assert (str.in.re X}\; R_n\; \texttt{))}* \\
    & \texttt{(assert (<= Min (str.len X)))}? \\
    & \texttt{(assert (<= (str.len X)) Max)}?
\end{align*}

where $R_i \in RegEx$, and $Min, Max \in Int$. More simply, the
instance is a set of one or more regex constraints on a single
variable, with optional maximum and minimum length constraints. The
regex constraints $R$ are each of the form:
\begin{align*}
  & \texttt{(re.++}\; \ T_0\; \ T_1\; \texttt{...}\; T_n\; \texttt{)}
\end{align*}

and each $T_i$ is a recursive term of the form:
\begin{align*}
  & \texttt{(re.*}\; T_{i_j}\; \texttt{) | (re.+}\; T_{i_j}\;
  \texttt{) | (re.union}\; T_{i_{j_1}}\; T_{i_{j_2}}\; \texttt{)}
\end{align*}

where $j$ is the specified depth of recursion. Terms at depth 0 are
regex constants. Informally, this form describes a concatenation of
regex terms. Each term is a random nested regex operator (chosen from
regex Kleene star, repetition, and union), up to a specified depth,
terminating in a regex literal. Below are three example regexes
(separated by spaces) of depth 2 produced by this scheme:
\begin{align*}
  & ((\texttt{a}|\texttt{b})|(\texttt{cc})+)\quad\quad
  ((\texttt{ddd})*)+\quad\quad ((\texttt{ee})+|(\texttt{fff})*)
\end{align*}

\fuzzer{} can also transform the instances it generates. All of the
transformers in \transformer{} can operate on regex terms. They can
multiply and permute regex literals (e.g. \textit{Reverse},
\textit{Multiply}, \textit{Translate}), randomly replace regex
operators (e.g. \textit{Fuzz}), and manipulate the syntax tree
(e.g. \textit{Graft}, \textit{Rotate}).

\subsubsection{Example Use Case}

\fuzzer{} can be used to generate benchmark suites in a batch mode, but also
in an online randomized fashion for exploratory debugging. For example,
\fuzzer{} can be invoked as follows to feed random instances to \cvc{} until it
returns an error:
{\scriptsize\begin{verbatim}
while stringfuzzg -r random-ast -m | tee instance.smt25 | cvc4 --lang smt2.5 --tlimit=5000; do
    sleep 0
done\end{verbatim}}

Simply by running the above script, we managed to induce segmentation faults
in \cvc{} and \us{}.
