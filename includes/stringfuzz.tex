\section{\fuzzer{}}
\label{sec:fuzzer}

\subsubsection{Implementation and Architecture}

\fuzzer{} is implemented as a Python package, and comes with several
executables to generate, transform, and analyze \smtfull{} string and regex
instances. Its components are implemented as \unix{} ``filters'' to enable easy
integration with other tools (including themselves). For example, the
outputs of generators can be piped into transformers, and transformers
can be chained to produce a stream of tuned inputs to a
solver. \fuzzer{} is composed of the following tools:

\begin{description}
    \item[\generator{}] \hfill \\
    This tool generates \smt{} instances. It supports several generators and
    options that specify its output. Details can be found in
    Table~\ref{tbl:generators}.
    \item[\transformer{}] \hfill \\
    This tool transforms \smt{}
    instances. It supports several transformers and options that specify
    its output and input, which are explained in
    Table~\ref{tbl:transformers}. Note that transformers
    \textit{Translate} and \textit{Reverse} also preserve
    satisfiability under certain conditions~\cite{ifaz}.
    \item[\texttt{stringstats}] \hfill \\
    This tool takes an \smt{}
    instance as input and outputs its properties: the number of
    variables/literals, the max/median syntactic depth of expressions, the
    max/median literal length, etc.
\end{description}

We organized \fuzzer{} to be easily extended. As evidence of our success we note
that while the whole project 
contains \linesInFuzzer{} lines of code, it takes an average of 
\linesPerX{} lines of code to create a transformer. \fuzzer{} can either be 
installed from source, or from the Python PIP package
repository.\footnote{The link to the source code will be added after double-blind review.}

\begin{table}[t]
    \centering
    \caption{\generator{} built-in generators.}
    \label{tbl:generators}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Name}
        & \textbf{Generate instances that have ...}
        \\ \hline
        \textit{Concats}
        & Long concats and optional random extracts.
        \\ \hline
        \textit{Lengths}
        & Many variables (and their concats) with length constraints.
        \\ \hline
        \textit{Overlaps}
        & An expression of the form A.X = X.B.
        \\ \hline
        \textit{Equality}
        & An equality among concats, each with variables or constants.
        \\ \hline
        \textit{Regex}
        & Regexes of varying complexity.
        \\ \hline
        \textit{Random-Text}
        & Random, likely syntactically \textit{in}valid text.
        \\ \hline
        \textit{Random-AST}
        & Random, but semantically \textit{valid} text.
        \\ \hline
    \end{tabular}
    
    \caption{\transformer{} built-in transformers.}
    \label{tbl:transformers}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Name}
        & \textbf{The transformer ...}
        & \textbf{Guarantee}\footnote{See Appendix for proofs and restrictions.}
        \\ \hline
        \textit{Fuzz}
        & Randomly replaces literals and operators with similar ones.
        & Well-formed
        \\ \hline
        \textit{Graft}
        & For each sort, swaps a random non-leaf node with a leaf node.
        & Well-formed
        \\ \hline
        \textit{Multiply}
        & Multiplies each number by N, and repeats each character N times.
        & Sat-sat
        \\ \hline
        \textit{Nop}
        & Does not transform (can translate between \smtfull{}).
        & Equisat
        \\ \hline
        \textit{Reverse}
        & Reverses all string literals and concat arguments.
        & Equisat
        \\ \hline
        \textit{Rotate}
        & Performs a syntax tree rotation on compatible operators.
        & Well-formed
        \\ \hline
        \textit{Translate}
        & Permutes the alphabet.
        & Equisat
        \\ \hline
        \textit{Unprintable}
        & Randomly replaces all characters in literals with unprintable ones.
        & Equisat
        \\ \hline
    \end{tabular}
\end{table}

\subsubsection{Regex Fuzzing Capabilities}

\fuzzer{} can generate
and transform instances with regular expression constraints. For example, the
command \texttt{stringfuzzg regex} invokes the regex instance
generator and produces an instance of the form:
\begin{align*}
    & \texttt{(assert (str.in.re X}\; R_0\; \texttt{))} \\
    & \texttt{(assert (str.in.re X}\; R_n\; \texttt{))}* \\
    & \texttt{(assert (<= Min (str.len X)))}? \\
    & \texttt{(assert (<= (str.len X)) Max)}?
\end{align*}

where $R_i \in RegEx$, and $Min, Max \in Int$. More simply, the
instance is a set of one or more regex constraints on a single
variable, with optional maximum and minimum length constraints. The
regex constraints $R$ are each of the form:
\begin{align*}
    & \texttt{(re.++}\; T_0\; \texttt{(re.++}\; T_1\;
    \texttt{...}\; \texttt{(re.++}\; T_{n-1}\; T_n\; \texttt{))}
\end{align*}

and each $T_i$ is a recursive term of the form:
\begin{align*}
    & \texttt{(re.*}\; T_{i_j}\; \texttt{) | (re.+}\; T_{i_j}\;
    \texttt{) | (re.union}\; T_{i_{j_1}}\; T_{i_{j_2}}\; \texttt{)}
\end{align*}

where $j$ is the specified depth of recursion. Terms at depth 0 are
regex constants. Informally, this form describes a concatenation of
regex terms, where each term is a random nested regex operator (chosen from
regex Kleene star, repetition, and union), up to a specified depth,
terminating in a regex literal. Below are three example regex instances
(separated by spaces) of depth 2 produced by this scheme:
\begin{align*}
    & ((\texttt{a}|\texttt{b})|(\texttt{cc})+)\quad\quad
    ((\texttt{ddd})*)+\quad\quad ((\texttt{ee})+|(\texttt{fff})*)
\end{align*}

\fuzzer{} can also transform problem instances.
This is done by manipulating parsed syntax trees.
By default most of the built-in transformers 
only guarantee well-formedness, however,
some can even guarantee equisatisfiability. Table~\ref{tbl:transformers} 
lists the built-in transformers and these guarantees.

\subsubsection{Example Use Case}
In Sect.~\ref{sec:suites} we use \fuzzer{} to generate benchmark suites in a batch mode.
We can also use \fuzzer{} for on-line exploratory debugging. 
For example, the script below repeatedly feeds random \fuzzer{} 
instances to \cvc{} until the solver produces an error:
{\scriptsize\begin{verbatim}
while stringfuzzg -r random-ast -m \
    | tee instance.smt25 | cvc4 --lang smt2.5 --tlimit=5000 --strings-exp; do
    sleep 0
done\end{verbatim}}
